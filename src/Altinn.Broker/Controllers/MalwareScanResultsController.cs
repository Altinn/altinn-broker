using System.Net;

using Altinn.Broker.Core.Repositories;
using Altinn.Broker.Webhooks.Models;

using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace Altinn.Broker.Webhooks.Controllers
{
    [ApiController]
    [Route("broker/api/v1/webhooks/malwarescanresults")]
    public class MalwareScanResultsController : Controller
    {
        private readonly IFileRepository _fileRepository;
        private readonly IFileStatusRepository _fileStatusRepository;

        public MalwareScanResultsController(IFileRepository fileRepository, IFileStatusRepository fileStatusRepository)
        {
            _fileRepository = fileRepository;
            _fileStatusRepository = fileStatusRepository;
        }

        /// <summary>
        /// Used to receive Malware Scan Results from Azure Defender.
        /// </summary>
        /// <returns>Should always return 200 OK when file status has been updated by Scan Result</returns>
        [HttpPost]
        public ActionResult ProcessMalwareScanResults(EventMessage eventMessage)
        {
            this.Response.StatusCode = (int)HttpStatusCode.OK;
            string blobUri = eventMessage.data.blobUri;
            string filePathForDatabaseSearch = blobUri.Split("/").Last();
            string result = eventMessage.data.scanResultType;
            
            Guid fileId = _fileRepository.GetFileIdByBlobUriAsync(filePathForDatabaseSearch).Result;
            
            if(fileId == Guid.Empty)
            {
                return NotFound();
            }

            if(result.Equals("malicious", StringComparison.InvariantCultureIgnoreCase))
            {
                _fileStatusRepository.InsertFileStatus(fileId, Core.Domain.Enums.FileStatus.Failed);
                return Ok();
            }
            else
            {
                _fileStatusRepository.InsertFileStatus(fileId, Core.Domain.Enums.FileStatus.Published);
                return Ok();
            }
        }
    }
}