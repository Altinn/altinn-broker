
using System.Security.Claims;
using System.Text.Json;

using Altinn.Broker.Application.PurgeFileTransfer;
using Altinn.Broker.Application.Middlewares;
using Altinn.Broker.Core.Application;
using Altinn.Broker.Core.Domain;
using Altinn.Broker.Core.Helpers;
using Altinn.Broker.Core.Repositories;
using Altinn.Broker.Core.Services.Enums;

using Hangfire;

using Microsoft.Extensions.Logging;

using OneOf;

namespace Altinn.Broker.Application;
public class MalwareScanningResultHandler(
    IFileTransferStatusRepository fileTransferStatusRepository,
    IFileTransferRepository fileTransferRepository,
    EventBusMiddleware eventBus,
    IResourceRepository resourceRepository,
    IServiceOwnerRepository serviceOwnerRepository,
    IIdempotencyEventRepository idempotencyEventRepository,
    ILogger<MalwareScanningResultHandler> logger,
    IBackgroundJobClient backgroundJobClient) : IHandler<ScanResultData, Task>
{
    public async Task<OneOf<Task, Error>> Process(ScanResultData data, ClaimsPrincipal? user, CancellationToken cancellationToken)
    {
        string fileTransferIdFromUri = data.BlobUri.Split("/").Last() ?? Guid.Empty.ToString();
        Guid fileTransferId;
        if (!Guid.TryParse(fileTransferIdFromUri, out fileTransferId))
        {
            throw new Exception($"Could not parse Guid from {fileTransferIdFromUri}");
        }
        var fileTransfer = await fileTransferRepository.GetFileTransfer(fileTransferId, cancellationToken);
        if (fileTransfer is null)
        {
            throw new Exception("File transfer not found");
        }
        var resource = await resourceRepository.GetResource(fileTransfer.ResourceId, cancellationToken);
        if (resource is null)
        {
            throw new Exception("Resource not found");
        }
        var serviceOwner = await serviceOwnerRepository.GetServiceOwner(resource.ServiceOwnerId);
        if (serviceOwner is null)
        {
            throw new Exception("Service owner not found");
        }
        if (fileTransfer.FileTransferStatusEntity.Status == Core.Domain.Enums.FileTransferStatus.Failed)
        {
            logger.LogWarning("Received malware scan result for file transfer {fileTransferId} with status {status}, expected status UploadProcessing. Ignoring the result.", fileTransferId, fileTransfer.FileTransferStatusEntity.Status);
            return Task.CompletedTask;
        }

        return await TransactionWithRetriesPolicy.Execute(async (cancellationToken) =>
        {
            var isFirstDelivery = await idempotencyEventRepository.TryAddIdempotencyEventAsync($"{fileTransferId}_malwarescan", cancellationToken);
            if (!isFirstDelivery)
            {
                logger.LogInformation("Ignoring duplicate malware scan result for {fileTransferId} with ETag {etag}", fileTransferId, data.ETag);
                return Task.CompletedTask;
            }
            if (data.ScanResultType.Equals("No threats found", StringComparison.InvariantCultureIgnoreCase))
            {
                logger.LogInformation("Non-malicious result for {fileTransferId} with result {scanResultType}: {details}", fileTransferId, data.ScanResultType, JsonSerializer.Serialize(data));
                await fileTransferStatusRepository.InsertFileTransferStatus(fileTransferId, Core.Domain.Enums.FileTransferStatus.Published, timestamp: data.ScanFinishedTimeUtc ?? DateTimeOffset.UtcNow, cancellationToken: cancellationToken);
                backgroundJobClient.Enqueue(() => eventBus.Publish(AltinnEventType.Published, fileTransfer.ResourceId, fileTransferIdFromUri, fileTransfer.Sender.ActorExternalId, Guid.NewGuid(), AltinnEventSubjectRole.Sender));
                foreach (var recipient in fileTransfer.RecipientCurrentStatuses)
                {
                    backgroundJobClient.Enqueue(() => eventBus.Publish(AltinnEventType.Published, fileTransfer.ResourceId, fileTransferIdFromUri, recipient.Actor.ActorExternalId, Guid.NewGuid(), AltinnEventSubjectRole.Recipient));
                }
                backgroundJobClient.Enqueue<IBrokerStorageService>((service) => service.SetContentHashForExistingBlob(serviceOwner, fileTransfer, cancellationToken));
            }
            else
            {
                logger.LogWarning("Suspicious scan result for file transfer {fileTransferId} with body {body}", fileTransferId, JsonSerializer.Serialize(data));
                await fileTransferStatusRepository.InsertFileTransferStatus(fileTransferId, Core.Domain.Enums.FileTransferStatus.Failed, timestamp: data.ScanFinishedTimeUtc ?? DateTime.UtcNow, $"Malware scan failed: {data.ScanResultType}. Extra details: " + JsonSerializer.Serialize(data), cancellationToken);
                backgroundJobClient.Enqueue(() => eventBus.Publish(AltinnEventType.UploadFailed, fileTransfer.ResourceId, fileTransferIdFromUri, fileTransfer.Sender.ActorExternalId, Guid.NewGuid(), AltinnEventSubjectRole.Sender));
                backgroundJobClient.Enqueue<PurgeFileTransferHandler>(handler => handler.Process(new PurgeFileTransferRequest
                {
                    FileTransferId = fileTransfer.FileTransferId,
                    PurgeTrigger = PurgeTrigger.MalwareScanFailed
                }, null, CancellationToken.None));
            }
            return Task.CompletedTask;
        }, logger, cancellationToken);
    }
}
public class Foo
{
    private readonly IFileTransferRepository _fileTransferRepository;
    public Foo(IFileTransferRepository fileTransferRepository)
    {
        _fileTransferRepository = fileTransferRepository;
    }
}
